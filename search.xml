<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工具类</title>
      <link href="/2025/08/30/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2025/08/30/%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><p>其构造方法是私有的，即无法实例化对象，其中有很多静态方法，可以通过 <code>类名.方法名()</code> 调用</p><h2 id="数学工具类"><a href="#数学工具类" class="headerlink" title="数学工具类"></a>数学工具类</h2><p>即 <code>Math</code> 类（final，并且构造方法为私有），其中封装了很多常用的数学方法（都是 <code>static</code>）</p><ul><li>abs / absExact ：求绝对值   （-2147483648会出错）</li><li>pow（a，b）：求a的b次方     （b = 0.5 → 开平方根</li><li>sqrt：求算术平方根</li><li>cbrt：求立方根</li><li>min / max ：求最小/最大值</li><li>ceil / floor / round ：向上/向下取整/四舍五入</li><li>random：求 [0.0，1.0)的随机数</li><li>sin / cos / tan / asin / acos / atan ：三角函数</li><li>log() / log10() ：以e / 10为底求某数的对数</li></ul><p>求以2为底4的对数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h2><p>即 <code>Arrays</code> 类，其中针对数组类型有很多方法（基本都是<strong>静态方法</strong>）</p><ul><li>toString ：打印数组  （多维数组：deepToString)</li><li>sort （数组名，排序规则）</li></ul><p>对数组进行从小到大排序<br>注：只能给引用数据类型的数组进行排序，如果数组是基本数据类型的，需要变成其对应的包装类</p><p><strong>排序规则</strong>：是一个接口 <code>Compare</code>，所以在调用方法时，需要传递这个接口的实现类对象作为排序的规则。由于只需要使用一次，所以直接用匿名内部类形式就行了</p><p><strong>底层原理</strong>：</p><p>利用插入排序 + 二分查找的方式进行排序</p><p>默认把0索引的数据当做是有序的序列，1索引到最后认为是无序的序列</p><p>遍历无序的序列得到里面的每一个元素，假设当前遍历得到的元素是A元素，则把A往有序序列中插入，插入时利用二分查找确定A元素的插入点</p><p>拿着A元素跟插入点的元素进行比较，比较的规则就是compare方法的方法体</p><p>如果方法的返回值是负数，则拿着A继续跟前面的数据进行比较</p><p>如果方法的返回值是正数 / 0，则拿着A继续跟后面的数据进行比较</p><p>直到能确定A的最终位置为止</p><p><strong>从小到大 ： o1 - o2</strong></p><p><strong>从大到小 ： o2 - o1</strong></p><ul><li>equals：判断两个数组的每个值是否相等 （多维数组：deepEquals)</li><li>fill ( 数组名 , int value )：将一个数组用某个值填充</li><li>copyOf （ 原数组 ，复制长度）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果新数组的长度小于原数组，会部分拷贝</p><p>如果新数组的长度大于原数组，会补上默认初始值</p><ul><li>copyOfRange （数组名，起始下标，终止下标）            指定范围进行数组拷贝<br><strong>注：包头不包尾，包左不包右</strong></li><li>（不是Arrays类的方法）System.arraycopy（用作复制数组名，起始下标，目标数组名，起始下标，复制长度）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>copy<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//arr的内容将从copy下标为2开始复制4个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>int binarySearch（名，值）：二分查找数组中的某个元素<br>如果存在，返回索引值<br>如果不存在，返回  <strong>- 插入点 - 1</strong></li></ul><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>提供了与系统相关的方法</p><ul><li>arraycopy(原数组，起始索引，目的数组，起始索引，拷贝个数）   进行数组的拷贝</li></ul><p>注：</p><ol><li>如果原数组和目的数组都是基本数据类型，那么二者的类型必须保持一致，否则会报错</li><li>在拷贝的时候需要考虑数组的长度，如果超出范围也会报错</li><li>如果原数组和目的数组都是引用数据类型，那么子类类型可以赋值给父类类型</li></ol><ul><li><p>exit ( int  status)    终止当前运行的Java虚拟机</p><p>  status:</p><ul><li>0 ：正常停止</li><li>非0：异常停止</li></ul></li><li><p>long currentTimeMillis( )   返回当前系统的时间毫秒值形式</p></li></ul><h3 id="计算机中的时间原点"><a href="#计算机中的时间原点" class="headerlink" title="计算机中的时间原点"></a>计算机中的时间原点</h3><p>1970-1-1  00:00:00</p><p>1秒 = 1000毫秒</p><p>1毫秒 = 1000微秒</p><p>1微秒 = 1000纳秒</p><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>表示当前虚拟机的运行环境</p><ul><li>Runtime getRuntime( )     创建一个当前系统的运行环境对象（只有一个）</li><li>exit (int status)                   停止虚拟机（System中调用的也是这个方法）</li><li>int availableProcessors( ) 获得CPU的线程数</li><li>long maxMemory( )           JVM<strong>能</strong>从系统中获取的总内存大小（单位byte）</li><li>long totalMemoty( )          JVM<strong>已经</strong>从系统中获取的总内存大小（单位byte）</li><li>long freeMemory( )           JVM剩余内存大小（单位byte）</li><li>Process exec(String command)   运行cmd命令</li></ul><h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><p>在计算机中，日期一般以时间戳的形式存在，是自1970年1月1日00:00:00（UTC时间）起到某一时刻的毫秒数。比如按照毫秒进行计时，当时间戳为1000时，就表示时间为1970年1月1日00:00:01这个时间。</p><h3 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h3><ul><li>Date类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Date</span> date1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不写参数默认为当前的时间</span><span class="token function">sout</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Date</span> date2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由于有参构造中参数（毫秒）类型为long，所以要写L</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方法：</p><ol><li>setTime(long time);</li><li>long getTime();           获取毫秒值</li></ol><ul><li>Calendar类</li></ul><p>代表了系统当前时间的日历对象，可以单独修改、获取时间中的年、月、日</p><ol><li>创建</li></ol><p>注：</p><ul><li>是抽象类，不能 <code>new</code> ，要调用<code>Calendar.getInstance()</code>获取一个代表当前日期时间的实例。<br>底层原理：会根据系统的不同时区来获取不同的日历对象，默认表示当前时间。会把时间中的纪元、年、月、日、时、分、秒、星期等都放到一个数组中</li><li>月份范围： 0~11               分别表示1月到12月</li><li>星期：星期日为一周的第一天</li></ul><ol><li>方法</li></ol><ul><li>Date getTime()                             获取日期对象</li><li>setTime(Date date)                     给日历设置日期对象</li><li>long getTimeInMillis()                获取时间毫秒值</li><li>setTimeInMillis(long millis)       给日历设置时间毫秒值</li><li>int get(int field)                            取日历中的某个字段信息</li><li>set(int field,int value)                  修改日历的某个字段信息</li><li>add(int field,int amout)               为某个字段增加/减少(amount为负数)指定的值</li></ul><p>Calendar类中，数组各索引对应的数字都被定义为了常量（年：YEAR   月：MONTH  日期：DAY_OF_MONTH等）</p><p> 例如：为一个日期对象设置年为2024</p><p><code>calendar.set(Calendar.YEAR, 2024);</code></p><pre><code>   提取日期和时间</code></pre><p><code>int year = calendar.get(Calendar.YEAR);</code></p><ul><li>DateFormat类</li></ul><p>可以实现字符串和日期的相互转换。由于其定义是一个抽象类无法直接使用，其常用的子类是<code>SimpleDateFormat</code>，通过配置能实现各种各样的日期转换</p><p>SimpleDateFormat类</p><ol><li>作用</li></ol><ul><li>格式化：把时间变成我们喜欢的格式</li><li>解析：把字符串表示的时间变成Date对象</li></ul><ol><li>构造</li></ol><ul><li>空参：使用默认格式（年/月/日  上/下午小时：分钟）</li><li>含参（String pattern)：使用指定格式</li></ul><ol><li>方法</li></ol><ul><li>String format(Date date)            格式化（日期对象 → 字符串）</li><li>Date parse(String source)          解析（字符串 → 日期对象）</li></ul><ol><li>使用</li></ol><ul><li>format</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Date</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>parse</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"2025-09-01 08:00:00"</span><span class="token punctuation">;</span><span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Date</span> d1 <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新"><a href="#新" class="headerlink" title="新"></a>新</h3><p><img src="/2025/08/30/%E5%B7%A5%E5%85%B7%E7%B1%BB/image.png"></p><p>新的类中的对象<strong>均不可变</strong></p><ol><li>Date类</li></ol><p>a.  ZoneId 时区</p><p>方法：</p><ul><li>static Set<string> getAvailableZoneIds()           获取Java中支持的所有时区（600个）</string></li><li>static ZoneId systemDefault()                                获取系统默认时区</li><li>static ZoneId of(String zoneId)                               获取一个指定时区</li></ul><p> b.  Instant 时间戳</p><p>表示时间线上的一个点，通常用来表示时间戳，打印结果与 <code>LocalDateTime</code> 在UTC+0的结果相同，相当于一个砍掉所有功能只用于保存时间的<code>LocalDateTime</code>对象</p><ul><li>static Instant now()                   获取当前时间的Instant对象（标准时间）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Instant</span> instant <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>static Instant ofXXX(long epochMilli)        根据（秒/毫秒/纳秒/）获取Instant对象</li><li>ZonedDateTime atZone(ZoneId zone)       指定时区</li><li>boolean isXxx(Instant otherInstant)          判断系列方法</li><li>Instant minusXxx( long )                               减少时间系列方法</li><li>Instant plusXxx( long )                                   增加时间系列方法</li></ul><p>c.  ZonedDateTime  带时区的时间</p><ul><li>static ZonedDateTime now()                       获取当前时间的ZonedDateTime对象</li><li>static ZonedDateTime ofXxx()                     获取指定时间的ZonedDateTime对象</li><li>ZonedDateTime withXxx(时间)                    修改时间系列方法</li><li>ZonedDateTime minusXxx(时间)                 减少时间系列方法</li><li>ZonedDateTime plusXxx(时间)                     增加时间系列方法</li></ul><ol><li>日期格式化类SimpleDateFormat</li></ol><p>DateTimeFormatter</p><p>用于时间的格式化和解析</p><ul><li>static DateTimeFormatter ofPattern(格式)                获取格式对象</li><li>String format(时间对象)                                                 按照指定方式格式化</li></ul><ol><li>日历类Calendar</li></ol><p>a.  LocalDate:  年、月、日</p><p><strong>静态方法</strong></p><ul><li>now   ： 创建当前日期的对象</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> date <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>of  （ year ，month ，date）  ： 创建某个年-月-日的日期对象</li><li>ofYearDay（year ， day）  ： 创建某一年第几天的对象</li></ul><p><strong>成员方法</strong></p><ul><li>getYear / getMonth / getDayOfMonth ： 得到对象的年，月（不是数字），日<ul><li>getMonthValue ： 得到月份数字</li><li>getDayOfWeek ：得到这周的第几天</li><li>getDayOfYear ： 得到这年的第几天</li></ul></li><li>plusDays / plusWeeks / plusMonths / plusYears ：在原基础上增加几天，周，月，年</li><li>minusDays / ……  ：减去</li><li>withYear / withMonth / withDayOfMonth ： 更改原对象的年，月，日</li><li>atTime ： 补齐时间</li><li>isLeapYear：判断是否为闰年</li></ul><p>b.  LocalTime:  时、分、秒</p><p>也就是能表示当前时间的日期类（不包括年月日），并且能精确表示到纳秒（10e-9秒）</p><p>方法和LocalDate差不多</p><ul><li>now ： 创建当前时间的对象</li><li>of （ hour ，minute ，second，纳秒）： 创建某个时-分-秒-纳秒的日期对象（hour和minute必写，之后可以不写，默认为0）</li><li>getHour / getMinute / getSecond / getNano： 得到时，分，秒，纳秒</li><li>plusHour / minusHour / ……. ：增加或减去多少时，分，秒</li><li>atDate ： 补齐日期</li></ul><p>c.  LocalDateTime:  年、月、日、时、分、秒</p><ul><li>LocalDate toLocalDate()                    转化为一个LocalDate对象</li><li>LocalTime toLocalTime()                    转化为一个LocalTime对象</li></ul><ol><li>工具类</li></ol><p>方法： </p><p>between（静态）</p><p>a.  Period : 时间间隔（年、月、日）（注意月是在同一年内计算，天是在同一月内计算）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Period</span> period <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">ofDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//表示相差时间1天</span><span class="token class-name">Period</span> period <span class="token operator">=</span> <span class="token class-name">Period</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里使用的是LocalDate</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>period<span class="token punctuation">.</span><span class="token function">getDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>b.  Duration : 时间间隔（秒、纳秒）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//通过between来计算两个时间的差值</span><span class="token class-name">Duration</span> duration <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusMinutes</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>duration<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处得到的是秒</span><span class="token class-name">Duration</span> duration <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//表示相差时间1秒</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>c.  ChornoUnit : 时间间隔（所有单位）</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常机制</title>
      <link href="/2025/08/30/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/08/30/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><p>在某些情况下，由于编写的代码不适当，会发生<strong>编译异常</strong>或<strong>运行异常</strong>，有时甚至会发生<strong>错误</strong>，出现异常时，程序都会在异常处终止运行</p><p>Exception：叫做异常，代表程序可能出现的问题</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>每一个异常都是一个类，并且都继承自 <code>Exception</code> 类（Exception类继承自 <code>Throwable</code> 类）</p><p>异常分为：<strong>运行时异常</strong>、<strong>编译时异常</strong></p><p><img src="/2025/08/30/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/1.png"></p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>如数组越界异常，空指针异常，算术异常</p><p><strong>特点</strong></p><p>编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><p>如使用Clone方法时，需要先使类实现 <code>Clonable</code> 接口，对Clone方法进行重写，才能使用clone方法，否则会抛出 <code>CloneNotSupportException</code> 异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Object类中的clone方法定义</span><span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误（Error）不属于异常（Exception），但二者都继承于Throwable</p><p>Error：代表系统级别错误（属于严重问题）<br>系统一旦出现问题，sun公司会把这些错误封装成Error对象，Error是给sun公司自己用的，不是给程序员用的，我们开发人员不用管它</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>异常时用来查询bug的关键参考信息</li><li>异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况（throw）</li></ol><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>分为三种：<strong>JVM默认的处理方式</strong>、<strong>自己处理</strong>、<strong>抛出异常</strong></p><h3 id="JVM默认的处理方式"><a href="#JVM默认的处理方式" class="headerlink" title="JVM默认的处理方式"></a>JVM默认的处理方式</h3><ol><li>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台</li><li>程序停止执行，异常下面的代码不会再执行了</li></ol><h3 id="自己处理（捕获异常）"><a href="#自己处理（捕获异常）" class="headerlink" title="自己处理（捕获异常）"></a>自己处理（捕获异常）</h3><ol><li>格式：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span><span class="token comment">//可能出现异常的代码；</span><span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token comment">//异常类名+变量名){</span><span class="token comment">//异常的处理代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>好处：可以让程序继续往下执行，不会停止</li><li>细节：</li></ol><ul><li><code>catch</code>中的代码只有在 <code>try</code>中出现了对应的异常才会执行</li><li>如果 <code>try</code> 中可能会遇到多个问题，要写<strong>多个</strong> <code>catch</code> 与之对应（但这些异常中如果存在父子关系的话，那么<strong>父类一定要写在下面</strong>）<br>在JDK 7 之后，我们可以在 <code>catch</code> 中<strong>同时</strong>捕获多个异常，中间用 <code>|</code> 进行隔开，表示如果出现了A异常或者B异常的话，采取同一种处理方案</li><li>如果 <code>try</code> 中遇到的问题没有被捕获，最终还是会交给虚拟机进行处理</li><li>如果 <code>try</code> 中遇到了问题，那么 <code>try</code> 下面的其他代码就不会执行了，直接跳转到对应的 <code>catch</code> 中</li></ul><h3 id="抛出处理"><a href="#抛出处理" class="headerlink" title="抛出处理"></a>抛出处理</h3><p>需要用到 <code>throws</code> 和 <code>throw</code> 两个关键字</p><ul><li>throws：</li></ul><ol><li>写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> 异常类名<span class="token number">1</span>，异常类名<span class="token number">2</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>编译时异常：<strong>必须要写</strong><br>运行时异常：可以不写</li></ol><ul><li>throw<br>写在方法内，结束方法。手动抛出异常对象，交给调用者，方法中下面的代码不再执行了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>使用的是定义在 <code>Throwable</code> 中的成员方法</p><table><thead><tr><th>String getMessage()</th><th>返回此throwable的详细消息字符串</th></tr></thead><tbody><tr><td>String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>void printStackTrace()</td><td>把异常的错误信息输出在控制台</td></tr></tbody></table><p>常用的方法是第三个 <code>printStackTrace</code> ，其底层是利用 <code>System.err.println</code> 进行输出，把异常的错误信息以红色字体输出在控制台，并且<strong>不会停止程序运行</strong></p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>定义异常类</li><li>写继承关系</li><li>空参构造</li><li>带参构造</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果想自定义一个<strong>编译</strong>时异常，可以新建一个类并继承 <code>Exception</code> 类</p><p>如果想自定义一个<strong>运行</strong>时异常，可以新建一个异常，此时idea会将其自动继承 <code>RunTimeException</code> 类</p><p>比如，新建一个运行时异常：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudyException</span> <span class="token keyword">extends</span> <span class="token class-name">RunTimeException</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">StudyException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//调用父类的带参构造方法</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在定义一个方法时，在异常分支下，可以选择<strong>抛出异常</strong></p><p>但是抛出运行时异常和编译时异常的情况略有不同</p><ul><li>运行时异常</li></ul><p>直接在异常分支下加 <code>throw new +异常()</code> ，小括号内可写抛出异常的原因</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">DivException</span><span class="token punctuation">(</span><span class="token string">"除数不能为0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">DivException</span> <span class="token keyword">extends</span> <span class="token class-name">RunTimeException</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">DivException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>编译时异常</li></ul><p>除了在异常分支下加 <code>throw new +异常()</code>外，还需要在方法后面加上 <code>throw 异常</code></p><p>即如果在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throw</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">DivException</span><span class="token punctuation">(</span><span class="token string">"除数不能为0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">DivException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">DivException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在方法的定义以及使用该方法的方法后面都需要加 <code>throw</code> ，如果方法中有多个异常，需要用逗号隔开，写上所有的异常</p><ul><li>特殊情况</li></ul><p>在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//此时子类中没有使用clone方法，所以不用写throw</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>就是为了让控制台的报错信息更加地见名知意</p><h2 id="出现异常时的打印信息"><a href="#出现异常时的打印信息" class="headerlink" title="出现异常时的打印信息"></a>出现异常时的打印信息</h2><p>当出现异常时：</p><p><img src="/2025/08/30/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/2.png"></p><p>程序会终止，并且会打印栈追踪信息，这里简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2025/08/30/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/08/30/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>主要用于简化匿名内部类的表示（Java8之后）</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li>只能适用于<strong>接口</strong>的匿名化实现，不能用于抽象类</li><li>接口中有且只有一个待实现的抽象方法（此时接口为<strong>函数式接口</strong>，接口上可以写 <code>@FunctionalInterface</code> 注解）</li></ul><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><p>标准格式为： </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span> 参数类型 参数名 <span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 参数类型可省略不写</p><p>例如，有一个Study接口，只含有study抽象方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Study</span> study <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"study抽象方法的实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Lambda表达式</span>study<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用study方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果抽象方法有形参，就在括号里面写上对应的数据类型和参数名就行了</p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="只有一个形参"><a href="#只有一个形参" class="headerlink" title="只有一个形参"></a>只有一个形参</h3><p>可以不写参数类型和小括号</p><h3 id="只有一个返回值"><a href="#只有一个返回值" class="headerlink" title="只有一个返回值"></a>只有一个返回值</h3><p>可以不用写大括号、分号和return（需要同时省略）</p><p>直接在 <code>-&gt;</code>后面写return的语句就行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token class-name">String</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Study</span> study <span class="token operator">=</span> a <span class="token operator">-&gt;</span> <span class="token string">"返回值为："</span><span class="token operator">+</span>a<span class="token punctuation">;</span>study<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="方法的参数是接口的实现"><a href="#方法的参数是接口的实现" class="headerlink" title="方法的参数是接口的实现"></a>方法的参数是接口的实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Study</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//此时test方法的参数是Study接口</span>s<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">test</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"Study接口实现"</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁、灵活的代码，作为一中更紧凑的代码风格，使Java语言表达能力得到了提升</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2025/08/30/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2025/08/30/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类，顾名思义是定义在类中的类。此时，可以将它们区分为外部类和内部类</p><p>内部类分为：成员内部类，静态内部类，局部内部类，匿名内部类</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exam</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"内部类"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><strong>注意：<strong>内部类和成员方法、成员变量一样，是</strong>对象所有的</strong>，而不是类所有的，如果我们要使用成员内部类，那么就需要：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//首先创建一个对象</span><span class="token class-name">Test<span class="token punctuation">.</span>Exam</span> exam <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在该对象基础上创建内部类的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者写成一行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Test<span class="token punctuation">.</span>Exam</span> exam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>成员内部类及其方法同样可以定义访问权限</li><li>成员内部类中可以使用外部类的成员变量，但是外部类无法使用成员内部类的成员变量（因为内部类是依附于外部类创建的，在外部类创建前，内部类的成员变量还没有创建）</li><li>Java16后，成员内部类中可以定义静态变量</li></ul><p><strong>同名情况</strong></p><p>如果外部类的成员变量与内部类的成员变量以及内部类的方法形参名相同，那么如何访问这三个变量呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span> <span class="token comment">//final表示该1变量只能被赋值一次并且之后不能改变</span>    <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法参数的name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//依然是就近原则，最近的是参数，那就是参数了</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成员内部类的name = "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//在内部类中使用this关键字，只能表示内部类对象</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成员内部类的name = "</span><span class="token operator">+</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对方法的调用</strong></p><ul><li>调用内部类中方法：   <code>.方法名()</code></li><li>内部类的父类方法： <code>.super.方法名()</code></li><li>外部类方法： <code>外部类名.this.方法名()</code></li><li>外部类父类方法： <code>外部类名.super.方法名()</code></li></ul><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>即在定义内部类时在访问权限后加 <code>static</code> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>不需要依附于类的对象，我们可以直接创建静态内部类的对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Outer.Inner为类的全名，并不指外部类的属性</span>                                         <span class="token comment">//注：如果在外部类的上下文中创建静态内部类的实例，</span>                                         <span class="token comment">//可以省略外部类的类名部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul><li>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建外部类的对象</li><li>调用静态内部类中的非静态成员方法：先创建静态内部类对象，再通过对象调用</li><li>调用静态内部类中的静态成员方法：直接通过 <code>外部类.内部类.方法名()</code> 调用</li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><h3 id="定义及创建"><a href="#定义及创建" class="headerlink" title="定义及创建"></a>定义及创建</h3><p>是定义在类的方法中的类</p><p>创建也是在方法中new一个并使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>            <span class="token comment">//定义Inner局部内部类</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"你好！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建实例对象</span>innner<span class="token punctuation">.</span><span class="token function">helloo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>局部内部类的作用范围仅在外部类的方法中</p><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>即没有名字的内部类，常用在抽象类的对象或接口的实例化创建中（其实不是真的没有名字，编译器会帮我们起），可以写在成员位置，也可以写在局部位置</p><p>（当然普通类的对象创建也能用，可以通过代码块或者一些方法给予一些初始属性）</p><h3 id="定义与创建"><a href="#定义与创建" class="headerlink" title="定义与创建"></a>定义与创建</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> 类名 <span class="token operator">/</span> 接口名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span>重写的方法<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于类来说，匿名内部类与外部类是<strong>继承</strong>关系</p><p>对于接口来说，匿名内部类与接口是<strong>实现</strong>关系</p><p>假如说有一个抽象类Person：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时test为抽象方法</p><p>通常，我们要用一个子类继承Person类并对test方法重写</p><p>通过内部类，可直接在main方法中创建Person对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"抽象方法的调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">//！！！注意这是一句话最后要加分号</span>person<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时在 <code>new Person()</code> 后加一个代码块表示匿名内部类的创建，在匿名内部类中依然可以定义成员变量和成员方法，同时匿名内部类中也可以访问抽象类的各种属性</p><p>创建一个匿名接口实现类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Study</span> study <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//或者： new Study(){</span><span class="token annotation punctuation">@Override</span>                     <span class="token comment">//         @Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment">//         public void study(){</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"匿名的接口实现类"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//            sout("study方法调用");</span><span class="token punctuation">}</span>                            <span class="token comment">//          }</span><span class="token punctuation">}</span>                              <span class="token comment">//        }.study();</span>study<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果在匿名内部类中使用外部类的局部变量（方法内部定义的变量），这些局部变量必须是&nbsp;<code>final</code>&nbsp;或者是“隐式的 final”（即在定义后不再被修改）</p><p>给出一种反例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">//代表a不是final</span><span class="token class-name">Study</span> study <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//错误！！</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringJoiner(Java8)</title>
      <link href="/2025/08/30/StringJoiner(Java8)/"/>
      <url>/2025/08/30/StringJoiner(Java8)/</url>
      
        <content type="html"><![CDATA[<h1 id="StringJoiner-Java8"><a href="#StringJoiner-Java8" class="headerlink" title="StringJoiner(Java8)"></a>StringJoiner(Java8)</h1><p>可以看成一个容器，创建以后里面的内容是可变的，同样支持链式调用</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>提高字符串的操作效率，且代码编写特别简洁。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span>间隔符号<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span>间隔符号<span class="token punctuation">,</span>开始符号<span class="token punctuation">,</span>结束符号<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>添加数据</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>返回长度，长度为字符的个数（不是字符串的个数）</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>变成字符串</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuilder类</title>
      <link href="/2025/08/30/StringBuilder%E7%B1%BB/"/>
      <url>/2025/08/30/StringBuilder%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p>我们已经知道String支持 + 和 +=，在实际使用中，如果多次出现这种写法，会比较浪费时间，因此编译器会对其进行优化，这是通过StringBuilder实现的</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>StringBuilder是专门用于构造字符串的，创建以后里面的内容是<strong>可变</strong>的。我们可以使用它来对字符串进行<strong>拼接、裁剪</strong>等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> builder1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一开始创建时为null</span><span class="token class-name">StringBuilder</span> builder2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="append！"><a href="#append！" class="headerlink" title="append！"></a>append！</h3><p>在字符串后面添加字符串，类似于C中的push_back</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除范围内的字符串 （int start , int end）这里指的都是下标</p><h3 id="deleteCharAt"><a href="#deleteCharAt" class="headerlink" title="deleteCharAt"></a>deleteCharAt</h3><p>删除某个下标对应字符</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>在某个下标对应的位置<strong>前面</strong>插入一个字符（串）</p><h3 id="reverse！"><a href="#reverse！" class="headerlink" title="reverse！"></a>reverse！</h3><p>对字符串进行翻转</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>将StringBuilder变回String</p><p>此外，该类中也支持String类中的所有方法，这是因为编译器执行了toString方法，将StringBuilder类转换为了String类</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>StringBuilder类支持链式调用（类似于C中的cout&lt;&lt;”dwa”&lt;&lt;a;)</p><p>当我们在调用一个方法时，不需要用变量接收它的结果，可以继续调用其他方法</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>链式调用的基本结构是，一个方法返回对象本身，这样你就可以在这行代码之后继续调用该对象的其他方法，式调用的实现依赖于每个方法返回对象自身（<code>this</code>），这样可以在一个语句中连续调用多个方法。</p><p>因此，可以有这种写法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="字符串拼接的底层原理"><a href="#字符串拼接的底层原理" class="headerlink" title="字符串拼接的底层原理"></a>字符串拼接的底层原理</h2><ul><li>拼接的时候没有变量，都是字符串</li></ul><p>此时会触发字符串的<strong>优化</strong>机制，在编译的时候就已经是最终的结果了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span> <span class="token operator">+</span> <span class="token string">"c"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>拼接的时候有变量参与</li></ul><p>JDK8以前会使用StringBuilder</p><ul><li>源码分析</li></ul><ol><li>默认创建一个长度（capacity）为16的字节数组</li><li>添加的内容长度（length）小于16，直接存</li><li>添加的内容大于16会扩容（16*2+2 = 34）</li><li>如果扩容之后还不够（&gt;34），以实际长度为准</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/2025/08/30/String%E7%B1%BB/"/>
      <url>/2025/08/30/String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>通过前面的学习，我们对String已经很熟悉了，String本质上是一个类，它不是基本数据类型</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>分为new和直接创建，<strong>创建出来的字符串不可变</strong>（StringBuilder可变）</p><ul><li>new（字符串，字符数组，字节数组）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>直接</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span> <span class="token comment">//推荐写法</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两种方法其实存在区别，请看下列代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时str1和str2字符串内容相同，使用直接法，二者引用的是同一个对象，因此如果判断 <code>==</code> 的话返回<strong>true</strong>，如果是new则返回false（优化效率，JDK8后字符串内容存在“字符串常量池”中，创建 <code>String</code> 时会先看串池中有无相同的字符串）</p><p>再看一个：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中str1存放的是<strong>堆</strong>中字符串的地址值，str2存放的是<strong>串池</strong>中字符串的地址值，二者<strong>并不相等</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><p>遍历字符串用</p><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><p>按照字典序比较两个字符串，小于返回负数，大于返回正数</p><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><p>判断字符串中是否包含某个字符串，返回boolean型</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>可以判断两个字符串是否内容相同</p><p><strong>equalsIgnoreCase</strong></p><p>判断是否相同，但是忽略大小写</p><h3 id="isBlank（Java11）"><a href="#isBlank（Java11）" class="headerlink" title="isBlank（Java11）"></a>isBlank（Java11）</h3><p>判断是否为空串 / 只由空格组成</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>查找字符串中某个字符对应下标（<strong>第一次出现</strong>） / 某个字符串第一个字符在字符串中对应下标</p><p>找不到返回-1</p><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><p>判空， <code>""</code> 为空串</p><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p>查找字符串中某个字符<strong>最后一次出现</strong>对应下标</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>求长度</p><h3 id="repeat（Java11）"><a href="#repeat（Java11）" class="headerlink" title="repeat（Java11）"></a>repeat（Java11）</h3><p>将字符串内容重复n次（n为形参）</p><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>替换某个字符 / 字符串 为另一个字符 / 字符串</p><p>注：如果是字符串，那么所有对应的字符串都会被替换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> rep <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"He"</span><span class="token punctuation">,</span><span class="token string">"Cia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照某个特定字符对String进行分割，并存入一个String数组中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="startsWith-endsWith"><a href="#startsWith-endsWith" class="headerlink" title="startsWith / endsWith"></a>startsWith / endsWith</h3><p>判断字符串是否以某个字符串开始 / 结尾</p><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>裁剪，有两种方法</p><ul><li>从下标为index处截到末尾  <code>substring(index);</code></li><li>从下标为index处截长度为len个 <code>substring(index,len);</code></li></ul><h3 id="toLowerCase-toUpperCase"><a href="#toLowerCase-toUpperCase" class="headerlink" title="toLowerCase / toUpperCase"></a>toLowerCase / toUpperCase</h3><p>将某个字符串全部转换为小写 / 大写字母，注意不是在原字符串中改变，而是创建了一个新的字符串</p><h3 id="trim（Java8）-strip（Java11）"><a href="#trim（Java8）-strip（Java11）" class="headerlink" title="trim（Java8）/ strip（Java11）"></a>trim（Java8）/ strip（Java11）</h3><p>去除字符串的前面和后面所有多余的空格（中间的空格不会去除）</p><p>当然还有：</p><ul><li>stripLeading：只去除前面的空格</li><li>stripTrailing：只去除后面的空格</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>String和字符数组可以相互转化</li><li>String支持加法，可以拼接（如果加的是一个类的对象，那么就默认调用toString方法）</li></ul><h3 id="文本块（Java15）"><a href="#文本块（Java15）" class="headerlink" title="文本块（Java15）"></a>文本块（Java15）</h3><p>类似于python的文本块，在Java15中新增了这个功能</p><p><em>当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</em></p><p>格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token triple-quoted-string string">""" "Hello World" """</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文本块有以下特性：</p><ul><li>可以在里面随意使用特殊字符，包括双引号和斜杠等，不用添加转义字符（当然这是一个语法糖，实际上编译器还是帮我们写了转义字符）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变长参数</title>
      <link href="/2025/08/16/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/"/>
      <url>/2025/08/16/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h1><p>在方法的形参中使用，可以使方法的形参接收多个数据</p><p>本质上就是一个数组</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><code>数据类型...参数名称</code></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表示该方法可以接收任意个String类型的参数，并将其打印，如果参数个数为0，则什么都不打印</p><h2 id="原理（访问）"><a href="#原理（访问）" class="headerlink" title="原理（访问）"></a>原理（访问）</h2><p>实质上是数组</p><p>如果想访问所传参数，用 <code>[]</code> 即可访问：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印第一个传入的参数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>可变参数必须放在形参列表的<strong>最后面</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>形参列表中可变参数<strong>只能有一个</strong></li></ol><h2 id="main中的String-args"><a href="#main中的String-args" class="headerlink" title="main中的String[] args"></a>main中的String[] args</h2><p>实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java com<span class="token operator">/</span>test<span class="token operator">/</span><span class="token class-name">Main</span> lbwnb aaaa xxxxx   #放在包中需要携带主类完整路径才能运行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，我们在后面随意添加的三个参数，都放到数组中了：</p><p><img src="/" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2025/08/16/%E6%95%B0%E7%BB%84/"/>
      <url>/2025/08/16/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组实际上也是一种类，但是编程不可见（底层C++写的，在运行时动态创建）</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>例如，创建一个int类型的大小为10的数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此此时的array仍然是一个引用变量，与类的对象的创建相同</p><p>此时10指明的数组的大小，并且在使用过程中数组的<strong>大小不可变</strong></p><p>也可以在创建时就赋值，但此时不能指明大小</p><p>也可以直接用大括号初始化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 示例 1：使用 new 关键字和大括号</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//注意此时中括号里面不能填大小</span><span class="token comment">// 示例 2：使用大括号直接初始化</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 示例 3：声明数组长度，但不初始化</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 所有元素默认为0,如果是对象就默认为null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>和C相同，用  <code>[ ]</code> 进行访问，下标同样是<strong>从0开始</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数组同样是继承Object类，具有一些方法</p><p>数组类中重写了clone方法，可以直接克隆数组。但是未重写equals，toString方法，因此不能通过equals方法直接对两个数组进行比较</p><ul><li>获得数组大小： <code>.length</code>    注意<strong>后面不加括号</strong>！！！这相当于是数组的一个属性</li></ul><p>在方法中的形参中，数组也要加上括号</p><p>例如，在Main中提供一个数组比较的equals方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//注意因为main方法为static，因此新定义的方法也要是static的</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length<span class="token operator">!=</span>b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for遍历数组的简化写法（foreach语法）"><a href="#for遍历数组的简化写法（foreach语法）" class="headerlink" title="for遍历数组的简化写法（foreach语法）"></a>for遍历数组的简化写法（foreach语法）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际上编译后还是转化为经典的for循环</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>对于基本类型的数组来说，是不支持自动装箱和拆箱的：即不能将一个基本类型的数组引用直接赋值给其包装类数组引用变量：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> arr1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但如果是引用类型就可以，支持向上转型和向下转型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> arr<span class="token punctuation">;</span>  <span class="token comment">//向下转型</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>如果定义数组时使用了 <code>final</code> ，其含义是引用变量只能指向所创建的数组，而不能指向别的数组，并不是数组的值不能改变</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">//可以改变</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>要创建几维，就在后面加几个 <code>[ ]</code> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//创建一个2×10的数组，2为两个一维数组（2行）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，也可以提前赋值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里要注意的是，多维数组创建出来的变量同样是一个引用变量，因此可以直接对其中的一维数组做出改变：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//注意先new，不能在原数组基础上改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>注：</p><p>Java中的多维数组的每一维的数组长度可以不相同，当你创建一个二维数组（实际上是数组的数组），你可以存储一维数组，它们的长度可以不同。与C语言不同，Java不会在短的一维数组后自动创建元素来填充它。这意味着你可以创建一个不规则的（或称为”锯齿形”）二维数组。</p><p>以二维数组的遍历为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密封类（Java17）</title>
      <link href="/2025/08/16/%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88Java17%EF%BC%89/"/>
      <url>/2025/08/16/%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88Java17%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="密封类（Java17）"><a href="#密封类（Java17）" class="headerlink" title="密封类（Java17）"></a>密封类（Java17）</h1><p>是用来规定父类能被特定子类继承的类，与 <code>final</code> 相区别，final一旦定义就不能被所有类继承</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在 <code>class</code> 前面加 <code>sealed</code> 同时在类名后面加 <code>permits 类名</code> 表示其允许继承的子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">permits</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>密封类型有以下要求：</p><ul><li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等</li><li>必须有子类继承，且不能是匿名内部类或是lambda的形式</li><li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li><li>• 继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li></ul><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p><strong>父类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token punctuation">[</span><span class="token keyword">abstract</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">class</span><span class="token operator">/</span><span class="token keyword">interface</span><span class="token punctuation">]</span> 类名 <span class="token punctuation">[</span><span class="token keyword">extends</span> 父类<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">implements</span> 接口<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">permits</span> <span class="token punctuation">[</span>子类<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token comment">//里面的该咋写咋写</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>子类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token punctuation">[</span><span class="token keyword">final</span><span class="token operator">/</span><span class="token keyword">sealed</span><span class="token operator">/</span><span class="token keyword">non-sealed</span><span class="token punctuation">]</span> <span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类 <span class="token punctuation">{</span>   <span class="token comment">//必须继承自父类</span><span class="token comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span>  <span class="token comment">//sealed类型：同父类，需要指定由哪些类继承。</span>  <span class="token comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录类（Java16）</title>
      <link href="/2025/08/16/%E8%AE%B0%E5%BD%95%E7%B1%BB%EF%BC%88Java16%EF%BC%89/"/>
      <url>/2025/08/16/%E8%AE%B0%E5%BD%95%E7%B1%BB%EF%BC%88Java16%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="记录类（Java16）"><a href="#记录类（Java16）" class="headerlink" title="记录类（Java16）"></a>记录类（Java16）</h1><p>是一种用来存放不可变的数据的类型，其存放的数据默认 <code>final</code> 类型，即不可更改</p><p>记录类不可继承，可以实现接口</p><p>在Java17后，记录类可以作为局部内部类编写</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用关键字 <code>record</code> 创建一个记录类型，此时和类不同，需要加一个<strong>小括号</strong>，里面存放该记录包含的所有属性：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">record</span> <span class="token class-name">Commodity</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> addresss<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>记录类型与前面说的枚举类型类似，本质上在编译之后也是一个普通的类，不过是final且继承自<code>java.lang.Record</code>抽象类的，它会在编译时，会自动编译出&nbsp;<code>public get</code>、&nbsp;<code>hashcode</code>&nbsp;、<code>equals</code>、<code>toString</code>&nbsp;等方法。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>依然使用 <code>new</code> 创建，是有参构造</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Commodity</span> commodity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Commodity</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"电脑"</span><span class="token punctuation">,</span><span class="token string">"北京市"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>commodity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//自动调用toString</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以在定义时重载方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/2025/08/16/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2025/08/16/%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>枚举也属于类，它继承自Enum类</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用关键字 <code>enum</code> ：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Status</span><span class="token punctuation">{</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span><span class="token constant">STUDY</span><span class="token punctuation">,</span><span class="token constant">SLEEP</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时枚举类中的RUNNING,STUDY,SLEEP都是以 <code>public static final Status</code> 类型存放，相当于一个Status类的成员变量</p><p>因此，枚举类中还可以定义成员变量，定义有参构造方法等。需要注意的是，如果定义了有参构造方法，RUNNING等状态都要在后面用 <code>( )</code>来进行参数绑定了，这是因为在Java中，枚举（<code>enum</code>）的构造方法是私有的，无法声明为<code>public</code>或<code>protected</code>，枚举中，构造函数默认是<code>private</code>的，如果尝试将其声明为<code>public</code>或<code>protected</code>，编译器会报错。因此，所有的枚举实例必须在枚举类内进行定义，不能在类外创建新的实例。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Status</span><span class="token punctuation">{</span><span class="token function">RUNNING</span><span class="token punctuation">(</span><span class="token string">"跑步"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">STUDY</span><span class="token punctuation">(</span><span class="token string">"学习"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">SLEEP</span><span class="token punctuation">(</span><span class="token string">"睡觉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token comment">//枚举的成员变量</span><span class="token class-name">Status</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//覆盖原有无参构造方法，注意不能加public！！</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>当做一个数据类型定义使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">Status</span> status<span class="token punctuation">;</span><span class="token comment">//Setter</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token class-name">String</span> status<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token operator">=</span>status<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//Getter</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在枚举类的Setter函数中，用 <code>枚举类名.内容</code> 来进行值的更改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>student<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token class-name">Status</span><span class="token punctuation">.</span><span class="token constant">RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印RUNNING</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印跑步</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//打印RUNNING </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口（可多接口）</title>
      <link href="/2025/08/16/%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%8F%AF%E5%A4%9A%E6%8E%A5%E5%8F%A3%EF%BC%89/"/>
      <url>/2025/08/16/%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%8F%AF%E5%A4%9A%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="接口（可多接口）"><a href="#接口（可多接口）" class="headerlink" title="接口（可多接口）"></a>接口（可多接口）</h1><p>接口代表某个确切的功能，即只包含方法的定义，甚至都不是一个类。</p><p>接口包含了一系列方法的定义，类可以实现这个接口，表示类支持接口代表的功能</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>接口用 <code>interface</code> 定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//实际上是public abstract void study();但是由于接口中只能定义访问权限</span><span class="token comment">// 为public的抽象方法，因此可以省略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时，想要实现该接口的类就要在定义中重写study抽象方法了，当然也可以在定义中写上接口的<strong>默认实现(default）</strong>（Java8之后），这样在子类中可以选择不重写方法</p><p>接口中不能包含成员变量和成员方法，但可以存在静态变量和静态方法</p><p>在定义接口中的静态变量时，不必显示地给出，其默认类型为 <code>public static final</code> 型，这意味着该变量不能再次被赋值</p><h3 id="默认方法（Java8）"><a href="#默认方法（Java8）" class="headerlink" title="默认方法（Java8）"></a>默认方法（Java8）</h3><p>定义格式：</p><p><code>public default 返回值类型 方法名（参数列表）{}</code></p><p>注意事项：</p><ul><li>默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写时去掉default关键字</li><li>public可以省略，default不能省略</li><li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</li></ul><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"默认实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//**注：默认实现不能是Object中已有的方法，但是可以重写**</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态方法（Java8）"><a href="#静态方法（Java8）" class="headerlink" title="静态方法（Java8）"></a>静态方法（Java8）</h3><p>定义格式：</p><p><code>public static 返回值类型 方法名（参数列表）{}</code></p><p>注意事项：</p><ul><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li><li><code>public</code> 可以省略， <code>static</code>不能省略</li><li>如果接口中的静态方法与类中的静态方法名相同，由于静态方法<strong>不在虚方法表中</strong>，因此两个方法不是重写关系，想要调用只要 <code>类名 / 接口名 + 方法名()</code> 即可</li></ul><h3 id="私有方法（Java9）"><a href="#私有方法（Java9）" class="headerlink" title="私有方法（Java9）"></a>私有方法（Java9）</h3><p>Java9后，允许接口中定义其private方法供内部使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"默认实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"一系列内部实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>包括静态方法在内，也可以使用<code>private</code>访问权限进行声明</p><p>在外面使用接口对应的对象时，跟类一样无法访问到私有成员。</p><h2 id="成员的特点"><a href="#成员的特点" class="headerlink" title="成员的特点"></a>成员的特点</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>只能是常量（默认修饰符：public static final）</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>没有</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只能是抽象方法（默认修饰符：public abstract）</p><ul><li>Java7 以前：接口中只能定义抽象方法</li><li>Java8：接口中可以定义有方法体的方法</li><li>Java9：接口中可以定义私有方法</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>类可以通过 <code>implements</code> 关键字来实现所需接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Study</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我会学习！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：在重写中使用接口的默认实现： <code>接口名.super.函数名()</code></p><p>如，在Student.java中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Study</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token class-name">String</span> sex<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Study</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我会学习!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个接口"><a href="#多个接口" class="headerlink" title="多个接口"></a>多个接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Study</span><span class="token punctuation">,</span><span class="token class-name">Walk</span><span class="token punctuation">,</span><span class="token class-name">Eat</span><span class="token punctuation">{</span><span class="token comment">//多个接口用逗号隔开</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在Main方法中，可以直接通过接口名来定义一个变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Study</span> student<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时student实质上还是Student类的引用，可以通过强制类型转换为Student类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时定义的变量只能使用接口中定义的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">student<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用clone方法（clone为浅拷贝）"><a href="#使用clone方法（clone为浅拷贝）" class="headerlink" title="使用clone方法（clone为浅拷贝）"></a>使用clone方法（clone为浅拷贝）</h3><p>clone是Object类中的方法，但子类要使用该方法时必须要提供 <code>Cloneable</code> 的接口，即：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Clonable</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，子类中重写的Cloneable方法，只需要把它的访问权限从protected改为public（否则外面不能用）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main中实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportException</span><span class="token punctuation">{</span><span class="token class-name">Student</span> stu<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> clone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> stu<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//强制类型转换</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使clone为stu的克隆，在执行stu==clone时返回的也是false（因为是不同对象）</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>接口也存在继承，同样使用 <code>extends</code> 关键字</p><p>需要注意的是，接口可以 <strong>多继承</strong> ，即extends后面可以跟多个接口，其效果就是子接口包括父接口的所有方法</p><p>并且，当子接口和父接口存在同名方法时，子接口方法会覆盖父接口方法</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>当父类中存在子类所接接口中的同名方法时，且该接口存在默认实现，那么类的对象在调用该方法时执行的是父类中的方法</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包</title>
      <link href="/2025/08/16/%E5%8C%85/"/>
      <url>/2025/08/16/%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包可以对不同的类进行分类</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>公司域名反写（不用写www.） + 包的作用</p><p>需要全部英文小写，见名知意</p><p>在将类放入不同的包时，需要在上面写一段话，使用关键字package</p><p>例如，将Main类放入com.test包中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ul><li>使用同一个包中的类时，不需要导包</li><li>使用 java.lang包中的类时，不需要导包</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类，需要用全类名</li></ul><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用import关键字：</p><p>例如：如果将Person类放入com.test.entity中，如何在Main类中访问Person呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Person</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：导入一个包中的所有内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>对于一个类中的静态变量和方法，可以使用静态导入，此时在Main中使用它们就不需要加上类的修饰了</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token static">test</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不同包中，可以创建相同类名的类</p><p>此时，在使用该类时，就要加上包名以防止歧义</p><p>当创建的类和Main类在不同包中时，就要注意访问权限控制了</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects类</title>
      <link href="/2025/08/16/Objects%E7%B1%BB/"/>
      <url>/2025/08/16/Objects%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h1><h2 id="方法（静态）"><a href="#方法（静态）" class="headerlink" title="方法（静态）"></a>方法（静态）</h2><h3 id="equals-Object-a-Object-b"><a href="#equals-Object-a-Object-b" class="headerlink" title="equals(Object a,Object b)"></a>equals(Object a,Object b)</h3><p>先做<strong>非空判断</strong>，再比较两个对象</p><p>细节：</p><ol><li>首先判断 a == b，不等的话，判断s1是否为null</li><li>如果s1不是null，那么就利用s1再次调用类中的equals方法</li><li>如果s1类中未重写equals方法就比较地址值，重写就按照重写的比较</li></ol><h3 id="isNull-Object-obj"><a href="#isNull-Object-obj" class="headerlink" title="isNull(Object obj)"></a>isNull(Object obj)</h3><p>判断对象是否为null，是返回true，不是返回false</p><h3 id="nonNull-Object-obj"><a href="#nonNull-Object-obj" class="headerlink" title="nonNull(Object obj)"></a>nonNull(Object obj)</h3><p>判断对象是否为null，不是返回true，是返回false</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2025/08/16/Object%E7%B1%BB/"/>
      <url>/2025/08/16/Object%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p><strong>所有的类都继承于Object类</strong>，因此所有的类中都包含Object类中的方法</p><p>其内容包括：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//标记为native的方法是本地方法，底层是由C++实现的</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                重要！！！！    <span class="token comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>                重要！！！！      <span class="token comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span>    <span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span>                重要！！！！    <span class="token comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"@"</span> <span class="token operator">+</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//唤醒所有等待当前对象锁的线程，同上</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使得持有当前对象锁的线程进入等待状态，同上</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>    <span class="token comment">//同上</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment">//同上</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><p>equals方法判断为true的条件是两个变量所指的是同一个对象，即使两个变量所指对象的所有属性都相同，只要它们所指的不是同一个对象，也会返回false</p><p>  这时就需要进行<strong>方法的重写</strong>了</p></li><li><p>Java中的拷贝（Clone）是<strong>浅拷贝</strong></p></li></ul><h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>返回对象的字符串表示形式（包名.类名@地址值）</p><p>直接 <code>println</code>对象的话也实际上是调用了 <code>toString</code> 方法</p><p>但是打印出地址值并没有什么实际用处，我们可以重写 toString方法</p><h3 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals (Object obj)"></a>equals (Object obj)</h3><p>比较两个对象是否相等（默认为地址是否相等）</p><p>一般来讲地址值对于我们意义不大，所以我们会重写（直接用IDEA提供的就行），重写之后比较的就是对象内部的属性值了</p><p>注：String类中有定义的equals方法，其先判断的是是否属于String类，StringBuilder中没有定义的equals方法</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>把A对象的属性值完全拷贝给B对象，也叫对象拷贝、对象复制</p><p>由于Object类中的clone方法为<strong>protected</strong>类型，这意味着<strong>只有同一个包内的类或子类才能访问它</strong>。<br>想要使用的话必须要<strong>重写</strong>clone方法并将其访问权限改为 <code>public</code>，并且要在使用方法的类中<strong>实现Cloneable接口</strong>，并且在main方法中要<strong>抛出CloneNotSupportedException异常</strong></p><p>注：Cloneable接口里没有任何方法</p><p>如果一个接口里面没有任何抽象方法，表示当前的接口是一个标记性接口</p><p>在克隆中，存在<strong>浅克隆</strong>和<strong>深克隆</strong></p><ul><li>浅克隆（clone默认）：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</li><li>深克隆：基本数据类型拷贝过来，字符串复用（串池），其他引用数据类型会重新创建新的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘录入</title>
      <link href="/2025/08/16/%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5/"/>
      <url>/2025/08/16/%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h1><p>使用 <code>Scanner</code> 类（java.util.Scanner)，有两套体系</p><ul><li>第一套体系<ul><li>next   接收字符串</li><li>nextInt 接收整数</li><li>nextDouble 接收小数</li></ul></li></ul><p>遇到空格，制表符，回车就停止接收</p><ul><li>第二套体系<ul><li>nextLine 接收字符串</li></ul></li></ul><p>可以接收空格，制表符，遇到回车才停止接收数据</p><p>第一、二套体系混用可能出现问题，例如先 <code>nextInt</code> ，再用 <code>nextLine</code> 。由于第一次输入整数后会加一个回车，会使第二个 <code>nextLine</code> 自动接收回车（换行符）而结束输入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//除了scanner为变量名外，其他固定</span><span class="token class-name">String</span> str <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测一行</span><span class="token class-name">String</span> str <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//检测直到空格等</span><span class="token keyword">int</span> sc <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测一个int类型的数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2025/07/24/%E7%B1%BB/"/>
      <url>/2025/07/24/%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="定义Java类："><a href="#定义Java类：" class="headerlink" title="定义Java类："></a>定义Java类：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用的Main其实也是一个类</p><p>之后在大括号里面可以定义该类的各种属性，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token class-name">String</span> name<span class="token punctuation">;</span>   <span class="token comment">//String大写</span><span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//注意结尾没有分号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用<strong>new</strong>来创建类的对象，类似于C++中为指针分配空间</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时p存放的就不是对象本身了，而是对象的引用</p><p>也可以创建一个空对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>对于类的对象来说，println会自动调用toString方法，不用显式地写出，不过默认toString会以 <code>类名+@+对象内存地址的十六进制</code>表示出来，想要正常表示需要重写toString函数</p><h3 id="访问和改变属性"><a href="#访问和改变属性" class="headerlink" title="访问和改变属性"></a>访问和改变属性</h3><p>使用 “ .  “  来访问对象的属性，并且做出修改。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">p<span class="token punctuation">.</span>name<span class="token operator">=</span>"别无选择“<span class="token punctuation">;</span>p<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：各种类型也是有初始值的，int等类型默认为0，bool默认为false，类类型默认为null</p><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><p>对于每一个类，可以在其中定义不同的方法，即函数</p><p>格式和函数定义一样</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">void</span> greet<span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"别无选择"</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法时，格式为：对象.方法名();</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Java类中也有this关键字，不过和C不同，此时this不是指针，使用时也不用“ →”来访问属性，而是使用” . “</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>Java类中也存在函数的重载，语法和C相同</p><p>区别：<strong>重写</strong></p><h3 id="添加代码块"><a href="#添加代码块" class="headerlink" title="添加代码块"></a>添加代码块</h3><p>在类定义中添加一个代码块，此时块中的代码会在构造对象时执行一次</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>"我是代码块“<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>每个类在定义时都隐含着一个默认的构造方法（构造器），其形式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无返回值，函数名与类名相同</p><p>可以自己显式地定义构造方法，此时默认构造方法会被覆盖掉。</p><p>注：代码块和构造方法的执行顺序：先代码块，再构造方法  </p><h2 id="静态变量，静态方法，静态代码块"><a href="#静态变量，静态方法，静态代码块" class="headerlink" title="静态变量，静态方法，静态代码块"></a>静态变量，静态方法，静态代码块</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>类中也可以定义静态变量，形式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">String</span> info<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时类中所有对象共用该’变量，并且可以用类名之间访问静态变量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>何时对静态变量进行初始化？</p><p>JVM只在类使用的时候才加载类，以下是加载类的情况：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说<strong>静态内容一定会在第一个对象初始化之前完成加载</strong></p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>和静态变量类似，用static修饰以定义静态方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时静态方法中<strong>只能访问静态变量和其他的静态方法</strong>，不能使用this , super关键字</p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>在创建一个类的对象时，先进行静态变量初始化，再执行静态代码块，再进行成员变量初始化，再执行普通代码块，再进行构造方法  </p><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><p>类和类的属性都有其访问权限，分为：默认，public，protected，private</p><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>访问权限可以是<strong>默认</strong>和<strong>public</strong></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="类的属性（变量和方法）"><a href="#类的属性（变量和方法）" class="headerlink" title="类的属性（变量和方法）"></a>类的属性（变量和方法）</h3><p>四种访问权限均可以</p><ul><li>默认：只能被类本身和同包中的其他类访问。</li><li>public：标记为公共的内容，允许在任何地方被访问。</li><li>protected：标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（继承）。</li><li>private：标记为私有的内容无法被除当前类以外的任何位置访问。</li></ul><p><img src="/2025/07/24/%E7%B1%BB/image.png"></p><p>注：访问权限的关键字均写在类/类属性的前面  </p><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><p>将类的变量都设置为private，通过getter和setter函数实现类的变量的访问和改变</p><p>也可以对类的构造方法做出改变：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> getName<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//设置默认构造方法为私有</span><span class="token keyword">private</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种方式可以实现单例（单例模式就是全局只能使用这一个对象，不能创建更多的对象）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token comment">//定义私有静态变量，此时insstance即为只能使用的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Person</span> instance<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>nulll<span class="token punctuation">)</span>instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的继承（无多继承）"><a href="#类的继承（无多继承）" class="headerlink" title="类的继承（无多继承）"></a>类的继承（无多继承）</h2><p>Java中类的继承要使用<strong>extends</strong>关键字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，Worker类为Person类的子类，Person类为Worker类的父类（超类）</p><p>子类继承了父类的所有属性，只要父类属性未用private修饰，那么子类都可以访问</p><p>注：类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  <span class="token comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在继承中，每个类中都有一个<strong>虚方法表</strong>，当子类中调用某个方法时，会先从虚方法表中寻找，这样提高了效率，其中未用 <code>private</code>  <code>static</code>  <code>final</code> 修饰的方法均会添加到虚方法表中</p><h2 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h2><ul><li>父类中的构造方法不会被子类继承</li><li>子类中所有的构造方法默认先访问父类中的无参构造，再访问自己</li></ul><p>为什么？</p><p>子类初始化时，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。因此子类构造方法第一句默认都是 <code>super()</code> 来调用父类的无参构造方法</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><h4 id="父类中的构造方法含参（不是默认）"><a href="#父类中的构造方法含参（不是默认）" class="headerlink" title="父类中的构造方法含参（不是默认）"></a>父类中的构造方法含参（不是默认）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token class-name">String</span> name<span class="token punctuation">;</span>                <span class="token comment">//可以用protected修饰变量，此时外部就不能访问这些变量了</span><span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token class-name">String</span> profession<span class="token punctuation">;</span><span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>profession<span class="token operator">=</span>profession<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好！我叫"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"今年"</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">"岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时子类必须要在构造方法中调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token string">"工人"</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">;</span>    <span class="token comment">//super代表父类，父类的构造方法就是super()</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注：super函数前不能有任何语句。</strong></p><p>为什么？</p><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了。</p><p>继承存在向上转型，即可以用子类当做父类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> person<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"别无选择"</span><span class="token punctuation">,</span><span class="token string">"18"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，此时也可以通过<strong>强制类型转换</strong>再将person转换为Student类（<strong>前提是它原本new的时候就为Student</strong>）[将一个被当做父类使用的子类对象，转换回子类]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> student<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span>person<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关键字instanceof"><a href="#关键字instanceof" class="headerlink" title="关键字instanceof"></a>关键字instanceof</h3><p>可以用来判断某个变量所引用的对象是否为某个类或者某个类的子类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//我们可以使用instanceof关键字来对类型进行判断</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象是 Student 类型的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> person<span class="token punctuation">;</span><span class="token comment">//先强转类型再使用方法</span>        student<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象是 Person 类型的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用instanceof时，如果要使用对应类的方法必须先强制转换类型</p><p>但是在Java16中提供了一种新写法**（类型判断模式匹配）**：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> student<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//这里的student即为强转后的变量名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象是 Student 类型的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同名"><a href="#同名" class="headerlink" title="同名"></a>同名</h3><p>子类可以定义与父类相同名称的变量，此时默认指向为子类中定义的变量</p><p>如果想要访问父类中该变量，可以使用super关键字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"别无选择"</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",我在工作！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Worker</span> worker<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时name将打印为”别无选择”</p><p>如果改为  <code>super.name()</code> ,将打印为”null”  （super只能往上跳一级，不能super.super)  </p><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>重写不同于重载，重载是为一个方法提供了多种形式，而重写则是将一个新的同名方法覆盖了原方法</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>在开头加一个注释 <code>@Override</code>,这样编译器可以检查重写形式的正确性（不加也行）</li><li>重写方法的名称，形参列表必须与父类中保持一致</li><li>子类重写父类方法时，访问权限 子类必须大于父类（默认&lt; protected &lt; public）</li><li>子类重写父类方法时，返回值类型子类必须小于等于父类</li><li><strong>建议：重写的方法尽量和父类保持一致</strong></li><li><strong>只有被添加到虚方法表中的方法才能被重写</strong></li></ul><p>例如，对Object中的equals方法进行重写，使其在不同对象只要变量值相同下就返回true：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token class-name">Person</span> person<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">==</span>person<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span>                  <span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此时对于Object定义的变量，但指向对象是Person来说，使用equals方法仍然对应的是重写之后的equals方法(  <code>Object object=new Person();</code> )</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>子类重写的方法内部其实也可以调用原本父类的方法（仅限类的定义中使用），此时要用到super关键字。</p><p>在使用之后执行时，程序不仅会执行原本父类的方法，也会接着执行子类的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原本的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"重写后的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><p>多态就是同类型的对象，表现出了不同的形态</p><p>表现形式：父类类型 对象名称 = 子类对象；</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>有继承关系</li><li>有父类引用指向子类对象（ <code>Fu f = new Zi()</code> ）</li><li>有方法重写</li></ul><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>编译看左边，运行也看左边</p><p>编译时判断父类中是否有该成员变量，运行时打印的也是该成员变量</p><p>解释：继承时子类会把父类的成员变量都继承下来</p><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>编译看左边，运行看右边</p><p>编译时判断父类中是否有该成员方法，运行时的是子类中的成员方法</p><p>解释：如果子类对方法进行了重写，那么虚方法表中是会把父类的方法进行覆盖的</p><h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>方法中，如果使用父类类型作为参数，就可以接收所有的子类对象</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不能调用子类中的特有方法</p><p>解决方案：再将父类对象强转为子类类型的对象，但是不能瞎转，如果转换为其他类型的子类就会报错，可以使用 <code>instance of</code> 先判断这个对象是否属于某个子类，再进行强制类型转换</p><p>补充： <code>instance of</code> 新特性<br>可以直接通过一行代码进行判断类型 + 强转</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//直接判断p是否属于Student类型，如果属于就强转为Student</span>p<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">Worker</span> w<span class="token punctuation">)</span><span class="token punctuation">{</span>p<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类中的final"><a href="#类中的final" class="headerlink" title="类中的final"></a>类中的final</h2><p>类中的final也是修饰在各种变量的前面的（但要放在访问权限后面，例如 <code>public final void test(){}</code></p><p>对于变量，加上final后，该变量在运行中只能被赋值一次</p><ul><li>基本数据类型：记录的值不能发生改变</li><li>引用数据类型：记录的地址值不能发生改变，内部的属性值还是可以改变的</li></ul><p>对于方法，加上final后，代表该方法处于最终形态，不能再被重写（能被重载）</p><p>对于类，表面该类是最终类，不能被继承</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>定义类时，在访问权限后加 <code>abstract</code> 关键字，可使该类变为抽象类</p><p>抽象类中可以定义抽象方法（并不是一定有抽象方法），形式与定义抽象类相同，<strong>函数体则是不用给出</strong>，此时子类中**必须重写(实现）**该抽象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token class-name">String</span> sex<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"会考试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时就<strong>无法使用new来创建Person类</strong>了，因为Person类为抽象类，而抽象类中可能会存在某些方法没有实现。<strong>只能创建它的子类</strong></p><p>（当然，也可以用<strong>匿名内部类</strong>直接new创建Person类）</p><p>因此，抽象类主要用作继承，而且抽象类的子类也可以是抽象类</p><p>注：抽象方法的访问权限不能是private</p><p>总结：</p><ul><li>抽象类不能实例化</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>可以有构造方法（在创建子类时对对象进行赋值）</li><li>抽象类的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java通过把基本类型（byte，short，int，float，double，char，boolean）各自封装为类，实现面向对象的功能</p><p>其对应如下：</p><ul><li>byte    →    Byte</li><li>short   →    Short</li><li>int       →    Integer</li><li>long    →    Long</li><li>float    →    Float</li><li>double→    Double</li><li>char     →    Charater</li><li>boolean→  Boolean</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ol><li>利用构造方法（Java5以前）</li></ol><p>这里以Integer为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，定义后，引用所指对象的值（这里是10）不能改变，它是 <code>final</code> 类型的（即使令i  = i+10，此时引用所指的是一个新的对象）</p><ol start="2"><li>利用静态方法 <code>valueOf</code> （Java5以前）</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8进制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="自动装箱拆箱-Java5"><a href="#自动装箱拆箱-Java5" class="headerlink" title="自动装箱拆箱(Java5)"></a>自动装箱拆箱(Java5)</h4><p>其实，包装类型支持<strong>自动装箱</strong>，即可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">//Integer i = Integer.valueOf(10)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时也支持拆箱：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">//int a= i.intValue();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，包装类就能轻松地参与到基本类型的运算中</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>值得注意的是，通过之前学习可知，即使引用所指类的成员变量相同，只要它们指的是不同对象， <code>==</code> 返回的就是false。对于自动装箱来说，这个结论<strong>不一定成立</strong>。</p><p>比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>返回的是 <code>true</code> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>返回的是 <code>false</code></p><p>这是因为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>   <span class="token comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span>        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IntegerCache会默认缓存-128<del>127之间的所有值，将这些值提前做成包装类放在数组中存放，如果直接让 -128</del>127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了</p><h4 id="判断值是否相等"><a href="#判断值是否相等" class="headerlink" title="判断值是否相等"></a>判断值是否相等</h4><p>用 <code>equals()</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串转数字（除了Character外都有）"><a href="#字符串转数字（除了Character外都有）" class="headerlink" title="字符串转数字（除了Character外都有）"></a>字符串转数字（除了Character外都有）</h4><ul><li>static int parseInt(String s)                      将字符串类型的整数转成int类型的整数</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="转进制（静态方法）"><a href="#转进制（静态方法）" class="headerlink" title="转进制（静态方法）"></a>转进制（静态方法）</h4><p>十六进制或八进制解码，转十进制</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token string">"0xA6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>十进制转其他进制</p><ul><li>static String toBinaryString(int i )          转二进制</li><li>static String toOctalString(int i)             转八进制</li><li>static String toHexString(int i)                转十六进制</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>Integer.sum(a,b)</li><li>Integer.max(a,b)</li><li>Integer.compare(a,b)</li></ul><p>等等…… </p><h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h3><p>void也有包装类，其名为Void</p><p>并且，Void类无法new，只能令其为null：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Void</span> v <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>```  ## 特殊包装类特殊包装类<span class="token operator">*</span><span class="token operator">*</span>没有自动装箱拆箱<span class="token operator">*</span><span class="token operator">*</span>，因此运算时要通过 `引用<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span><span class="token punctuation">)</span>` 进行运算### <span class="token class-name">BigInteger</span>可以用于<span class="token operator">*</span><span class="token operator">*</span>非常大整数<span class="token operator">*</span><span class="token operator">*</span>的运算#### 导入```java<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ol><li>非静态</li></ol><ul><li>(int num,Random rnd)    获取随机大整数，[ 0，2的num次方-1]</li><li>(String val)   获取指定的大整数</li><li>(String val,int radix) 获取指定进制的大整数</li></ul><ol start="2"><li>静态</li></ol><ul><li>valueOf(long val)  获取BigInteger的对象，内部有优化</li></ul><p>注：</p><ol><li>但是能表示范围比较小，只能在long的取值范围之内</li><li>在内部对常用的数字： -16 ~16 进行了优化<br>提前把 -16 ~16 先创建好BigInteger的对象，如果多次获取不会重新创建新的对象</li><li>一旦创建，内部记录值不能改变</li><li>只要进行计算都会产生一个新的BigInteger对象</li></ol><p>不能通过 <code>new</code> 创建了，而要通过 <code>.valueOf(值)</code> 创建：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigInteger</span> i <span class="token operator">=</span> <span class="token class-name">BigInteger</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>add，subtract，multiply，divide    加减乘除</li><li>(返回数组) divideAndRemainder      除法，获取商和余数(0为商，1为余数)</li><li>equals  比较是否相同</li><li>pow  次幂</li><li>max / min</li><li>intValue / longValue / doubleValue 转为int / long / double型（注意不能超出范围）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigInteger</span> i <span class="token operator">=</span> <span class="token class-name">BigInteger</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//将i的值乘1000后存入i中,注意1000的类型也是BigInteger</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>以4字节为一块，存入数组</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>可以用于<strong>小数的精确计算</strong></p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><ol><li>非静态</li></ol><ul><li>(double val)  这种方式有可能是不精确的，不建议使用</li><li>(String val)</li></ul><ol start="2"><li>静态</li></ol><ul><li>valueOf(double val)   也有范围</li></ul><p>注：</p><ol><li>如果数字不大，没有超出double的取值范围，建议使用静态</li><li>如果超出String构造</li><li>如果传递的是 [0，10] 的整数，那么方法会返回<strong>已经创建</strong>好的对象，不会重新new</li></ol><h4 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h4><ul><li>add , subtract , multiply , divide   加减乘除</li><li>divide(BigDecimal val，精确位数，舍入模式)</li></ul><p>除不尽的时候使用</p><p>注：舍入模式<br>在 <code>RoundingMode</code> 类中，需要通过其中不同的枚举指定<br>UP : 远离零方向<br>DOWN : 向零方向<br>CEILING : 向正无穷<br>FLOOR : 向负无穷<br>HALF_UP : 四舍五入<br>HALF_DOWN : 五舍六入</p><h4 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h4><p>每一个数字（包括小数点）遍历后存入字节数组中（存放ASCII码）</p><h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><p>不可变类是指一旦创建其对象后，其状态（属性值）就不能被改变的类。这意味着你不能对一个不可变对象的属性进行修改。常见的不可变类有&nbsp;<code>String</code>、<code>Integer</code>、<code>LocalDate</code>&nbsp;等</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>不可变类是在定义类时就加上了final，因此无法被继承和更改</p><h3 id="字符串内容的不可变性"><a href="#字符串内容的不可变性" class="headerlink" title="字符串内容的不可变性"></a>字符串内容的不可变性</h3><p> 在 Java 中，<code>String</code>&nbsp;对象本身是不可变的。这意味着一旦创建了一个&nbsp;<code>String</code>&nbsp;对象，它的内容不能被改变。你可以对&nbsp;<code>String</code>&nbsp;进行操作（例如，连接、切割等），但<strong>产生的结果将是一个新的&nbsp;<code>String</code>&nbsp;对象，而不改变原有的&nbsp;<code>String</code></strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环结构</title>
      <link href="/2025/07/24/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2025/07/24/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><ul><li>跳出外层循环：打标签</li></ul><p>例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">outer<span class="token operator">:</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>inner<span class="token operator">:</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token keyword">break</span> outer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Switch表达式</title>
      <link href="/2025/07/22/Switch%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/07/22/Switch%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Switch表达式"><a href="#Switch表达式" class="headerlink" title="Switch表达式"></a>Switch表达式</h1><h2 id="Java14"><a href="#Java14" class="headerlink" title="Java14"></a>Java14</h2><p>提供了新的switch语法，即：</p><p>switch的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment">//直接让res接收switch的结果</span><span class="token keyword">char</span> res <span class="token operator">=</span> <span class="token keyword">switch</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">-&gt;</span> <span class="token char">'A'</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token char">'B'</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token char">'C'</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token char">'D'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">//注意这是一个赋值语句，后面要加分号</span><span class="token function">sout</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即switch有了返回值，变量需要接收，switch语句中的冒号，break等也不在了，取而代之的是箭头。</p><p>当然，如果除了返回值外，还需要执行别的操作，可以写成代码块的形式，此时要用到关键字 <code>yield</code>,表示延迟返回：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">char</span> res <span class="token operator">=</span> <span class="token keyword">switch</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">-&gt;</span> <span class="token char">'A'</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span> <span class="token operator">-&gt;</span> <span class="token char">'B'</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token char">'C'</span><span class="token punctuation">;</span><span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">yield</span> <span class="token char">'D'</span><span class="token punctuation">;</span>   <span class="token comment">//指定延迟返回的结果，并自动结束分支</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="switch模式匹配（Java21后）"><a href="#switch模式匹配（Java21后）" class="headerlink" title="switch模式匹配（Java21后）"></a>switch模式匹配（Java21后）</h2><p>即switch除了可以根据变量的不同值做出判断外，增加了一个新功能：<strong>判断变量类型（只能是引用类型，Java25之后可以是基本类型）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tellInstance</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">String</span> type <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-&gt;</span> <span class="token string">"Integer"</span><span class="token punctuation">;</span>   <span class="token comment">//i和s为定义的返回值的变量名</span>          <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-&gt;</span> <span class="token string">"String"</span><span class="token punctuation">;</span>          <span class="token keyword">case</span> <span class="token keyword">null</span> <span class="token operator">-&gt;</span> <span class="token string">"Null"</span><span class="token punctuation">;</span>  <span class="token comment">//null和default直接加箭头</span>          <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token string">"Other"</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//记得每个语句和最后加分号</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们注意到，模式匹配中的类型后面必须跟一个变量名字，能否有一种办法省略掉呢？在Java 22之后，我们可以使用<code>_</code>下划线来直接取代，表示这是一个后续不会使用的未命名的变量</p><p>如果除了判断类型，我们还想判断别的，可以使用 <code>when</code> 关键字，在后面加上想要额外判断的条件进行额外条件检查，这种操作称为”守卫条件”</p><p><code>when</code>后面需要填写判断条件，和<code>if</code>一样，必须为一个返回值为<code>boolean</code>的表达式，也可以使用与或非操作</p><p>这样，在switch中也可以实现<strong>区间判断</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tellGrade</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">String</span> type <span class="token operator">=</span> <span class="token keyword">switch</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">case</span> <span class="token class-name">Integer</span> i when score <span class="token operator">&gt;=</span> <span class="token number">90</span> <span class="token operator">-&gt;</span> <span class="token string">"A"</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token class-name">Integer</span> i when score <span class="token operator">&gt;=</span> <span class="token number">80</span> <span class="token operator">-&gt;</span> <span class="token string">"B"</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token class-name">Integer</span> i when score <span class="token operator">&gt;=</span> <span class="token number">60</span> <span class="token operator">-&gt;</span> <span class="token string">"C"</span><span class="token punctuation">;</span>         <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token string">"D"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><p>此外，针对于此前提到的记录类型，在<code>switch</code>语句中支持直接解构使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>  <span class="token comment">//直接解构其参数使用</span>        <span class="token keyword">case</span> <span class="token class-name">String</span> _ <span class="token operator">-&gt;</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里针对于记录类型，类似重新写了一次类型声明，编写完整的类名加参数<code>Point(int x, int y)</code>表示当<code>object</code>如果是记录类型，则进入此分支且解构其内部成员变量，这里写的<code>x</code>和<code>y</code>作为结构出来的变量可以直接在后续使用。同样的，解构的变量如果后续不使用也可以直接使用下划线代替。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> _<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> y<span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token class-name">String</span> _ <span class="token operator">-&gt;</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>switch</code>还支持对记录类内部成员的类型嵌套匹配：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">record</span> <span class="token class-name">Container</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">//这里data是Object类型的</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Container</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token class-name">Container</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//其内部类型如果是String</span>        <span class="token keyword">case</span> <span class="token class-name">Container</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> i<span class="token punctuation">;</span>  <span class="token comment">//其内部类型如果是Integer</span>        <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Switch表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2025/07/22/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/07/22/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p>分为左移和右移运算符</p><p>但是右移多了一个<strong>考虑符号位的右移（逻辑右移）</strong>，即：”&gt;&gt;&gt;”</p><p>正常的右移是左面补齐符号位，但&lt;&lt;&lt;则是连同符号位一起右移，左边补0</p><h3 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h3><p><img src="/2025/07/22/%E8%BF%90%E7%AE%97%E7%AC%A6/img.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量与常量</title>
      <link href="/2025/07/22/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"/>
      <url>/2025/07/22/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>可以定义变量为常量，使其只能被赋值一次（类似于static）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li><p>byte 字节型（1个字节）：-128~127</p></li><li><p>short 短整型（2个字节）</p></li><li><p>int（4个字节）</p></li><li><p>long （8个字节）</p><p>  定义long类型常量时，要在数字后面加L</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">18231723932L</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  同时，针对这种很长的数字，可以用下划线分割每一位</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">182_2313_312_31L</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>八进制表示：前面加0</p><p>十六进制表示：前面加0x</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><ul><li><p>float</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">1.5F</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>double</p></li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>char ：<strong>2个字节</strong></li></ul><p>（ps：字符串类型：String (是对象类型) ）</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><ul><li>boolean</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><ul><li>整数：0</li><li>小数：0.0</li><li>字符：’/u0000’</li><li>布尔：false</li><li>引用：null</li></ul><h3 id="局部变量类型推断（Java10）"><a href="#局部变量类型推断（Java10）" class="headerlink" title="局部变量类型推断（Java10）"></a>局部变量类型推断（Java10）</h3><ul><li>var</li></ul><p>可以根据上下文自动推断数据类型（但是用的比较少）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印</title>
      <link href="/2025/07/22/%E6%89%93%E5%8D%B0/"/>
      <url>/2025/07/22/%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>因为有C语言和C++的一点基础，所以Java中有相似的都不再列出，只做Java中一些不同的写法和新的内容  </p><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>打印代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不换行</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//换行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印时，用+号来连接内容</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数字i的值为："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>idea快速写打印代码：</p><p>写 <strong>sout</strong> 即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今后的博客</title>
      <link href="/2025/07/22/%E4%BB%8A%E5%90%8E%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/07/22/%E4%BB%8A%E5%90%8E%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>好久没更新博客了，原因是我以为只能 通过VC来编辑博客，这太麻烦了。而我一般用notion来做笔记，这就导致搁置了博客的更新，而且我也不知道该在博客上放什么了。<br>今天在学习的时候偶然想到notion页面能不能导出为md文件，搜了一下果然可以！于是我把笔记都导出来了，这样博客也能每天同步更新了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增加了评论功能！</title>
      <link href="/2025/06/06/%E5%A2%9E%E5%8A%A0%E4%BA%86%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%81/"/>
      <url>/2025/06/06/%E5%A2%9E%E5%8A%A0%E4%BA%86%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="为博客新增了评论功能！"><a href="#为博客新增了评论功能！" class="headerlink" title="为博客新增了评论功能！"></a>为博客新增了评论功能！</h1><p>现在可以自由地在在博客下面评论了（不过需要我每天进入leancloud进行初始化），使用的是github上的<strong>Valine</strong>,具体见<a href="https://github.com/xCss/Valine">https://github.com/xCss/Valine</a><br>以前用gitment，但是登录github账号时会有问题，而且现在使用gitment的网站也有相同的问题。今天在读某篇博客时，意外看到了它的评论区，于是顺藤摸瓜找到了Valine。<br><em>注意</em>：手机端评论无法正常显示，但是可以发送</p>]]></content>
      
      
      
        <tags>
            
            <tag> 新功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2025/06/05/markdown-1/"/>
      <url>/2025/06/05/markdown-1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Markdown是一种轻量级的标记语言，设计初衷是让人们可以使用简单的文本格式来书写和编辑文档。<br>Markdown文件通常以.md或.markdown为扩展名。像我现在的博客都是以.md为扩展名的文件。  </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>普通文本</strong>：直接书写即可<br><strong>换行</strong>：在想要换行的末尾处加两次空格，然后再回车<br><strong>换段落</strong>：两次回车，此时与<strong>换行</strong>的区别是两行的间距更大。<br><strong>斜体</strong>:在想要斜体的部分的前后各加一个” * “<br><strong>加粗</strong>：在想要加粗部分的前后各加两个” * “，或者两个” _ “<br><strong>加粗并斜体</strong>:前后各加三个” * “<br><strong>删除线</strong>：前后各加两个” ~ “<br>     <strong>斜体，加粗，删除线可自由搭配</strong><br><strong>分割线</strong>：一行中输入三个或以上的” * “或” _ “(后面不能写别的东西,可以加空格)<br>如：  </p><hr><p><strong>一级~六级标题</strong>：想要添加几级标题，就以几个” # “ 后跟空格作为开头，之后写标题内容即可<br><strong>无序列表</strong>：以一个” * “或一个” - “或一个” + “后跟空格开头，后跟列表内容，如果三个符号混着用也会当做不同列表分开一段距离<br>如：  </p><ul><li>第1项</li><li>第2项</li></ul><ul><li>第1.1项</li><li>第1.2项</li></ul><p><strong>有序列表</strong>：数字+” . “+空格（数字作为起始点，之后列表编号依次加一）<br><strong>多级列表</strong>：在要分级的列表前加四个空格<br>如：  </p><ul><li>一级列表<ul><li>二级列表</li></ul></li><li>一级列表</li></ul><p><em><strong>注</strong></em>：列表在换行时，如果要在列表内进行换行，就按照后面加两个空格加回车即可，如果要在列表外进行换行，就必须要两次回车了<br>例：  </p><ul><li>编号1<br>编号1内的换行</li></ul><p>编号1外的换行<br><strong>勾选框</strong>：” * “ +” [ ] “后跟空格，默认为未勾选状态，如果要变为勾选状态就在方括号之间加”x”（大小写均可）<br>例：  </p><ul><li><input disabled="" type="checkbox"> 未完成的项目</li><li><input checked="" disabled="" type="checkbox"> 完成的项目<br><strong>代码块</strong>：<br>行内可以在内容前后各加一个” ` “ ,</li></ul><p>如 <code>sort()</code><br>如果是整个代码，则要在代码行前后各加三个” ` “   </p><p>并且在行前的三个” ` “ 后加对应语言名称(c,java…)<br>如： </p><pre class="line-numbers language-none"><div class="caption"><span>测试.cpp</span></div><code class="language-none">#include&lt;iostream&gt;using namespace std;int main(){    int a;    cout&lt;&lt;a;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文本引用</strong>：<br>在行前加” &gt; “ , 并且引用可以嵌套，建议每一行之前都加这个符号用于区分<br>如：  </p><blockquote><p>这是一段引用  </p><blockquote><p>引用的嵌套  </p></blockquote></blockquote><p><strong>超链接</strong>：在想插入超链接的文本前后用[]括起，之后在（）里面写入链接<br>例如：<br>想要了解更多信息请前往<a href="https://monster.havenochoice.cn/">官网</a><br>同时也可以在用[]括起的文本后再加一个[]里面可以写入一个变量名，之后在源文件中定义该变量的网址，这样就不需要加()了。<br><strong>脚注</strong>：在想添加脚注的文字后面写[^1]（1代表序号）<br><strong>插入图片</strong>：”!” + “[]” + “()”,括号地面写图片的地址<br>其他的语法暂时用不到，先到这里 </p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2025/06/05/my-first-post/"/>
      <url>/2025/06/05/my-first-post/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇博客！"><a href="#这是我的第一篇博客！" class="headerlink" title="这是我的第一篇博客！"></a>这是我的第一篇博客！</h1><p>从安装hexo，选择了一个主题，并在本地部署，再到注册购买域名，到versal项目对网站进行部署（不过中间间隔了三个多月）我学到了很多，最终还是决定搭建一个自己的博客网站，用来记录自己的学习过程。虽然评论功能因为插件问题，以及我目前能力不足还无法实现，但我相信我会把这个网站逐渐完善的！<br>现在我的水平可以说是一个小白，还有很多很多不会的东西，那就先从markdown语法学起吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
